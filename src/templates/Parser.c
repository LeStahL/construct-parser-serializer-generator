/* 
 * Generated by construct-c (c) 2023 Alexander Kraus <nr4@z10.info>.
 * Generation timestamp: {{ info.now }}
 * Note: If you plan to edit this file, please reconsider your plan.
 */

{%- macro generate_sizeof(tree, con) %}
size_t sizeof_{{ caseConversionService.convertToSnake(con.name) }}({{ caseConversionService.convertToSnake(con.name) }}_t *instance) {
    size_t result = 0.;
    {%- for key in tree %}
        {%- set subcon = tree[key] %}
    // {{ key }} with type {{ generatorService.cType(subcon) }}:
        {%- if generatorService.hasComputableSize(subcon) %}
    result += {{ generatorService.computableSize(subcon) }};
        {%- else %}
            {%- if generatorService.isArrayLike(key, tree) %}
    result += {{ generatorService.instance(generatorService.referencedSize(tree, key), 'instance') }};
            {%- elif generatorService.isStruct(key, tree) %}
    result += sizeof_{{ generatorService.cType(subcon) }}({{ generatorService.instance(key, 'instance') }});
            {%- else %}
    // Unhandled @ {{ key }} / {{ subcon }}
            {%- endif %}
        {%- endif %}
    {%- endfor %}
    return result;
}
{%- endmacro %}

{%- macro generate_parser(tree, con) %}
void parse_{{ caseConversionService.convertToSnake(con.name) }}({{ caseConversionService.convertToSnake(con.name) }}_t *instance, uint8_t *source) {
    size_t offset = 0;
    {%- for key in tree %}
        {%- set subcon = tree[key] %}
    // {{ key }} with type {{ generatorService.cType(subcon) }}:
        {%- if generatorService.hasComputableSize(subcon) %}
    {{ generatorService.instance(key, 'instance') }} = *({{ generatorService.cType(subcon) }} *)(source + offset);
    offset += {{ generatorService.computableSize(subcon) }};
        {%- else %}
            {%- if generatorService.isString(key, tree) %}
    {{ generatorService.instance(key, 'instance') }} = (char *) malloc({{ generatorService.instance(generatorService.referencedSize(tree, key), 'instance') }});
    memcpy({{ generatorService.instance(key, 'instance') }}, source + offset, {{ generatorService.instance(generatorService.referencedSize(tree, key), 'instance') }});
    offset += {{ generatorService.instance(generatorService.referencedSize(tree, key), 'instance') }};
            {%- elif generatorService.isArray(key, tree) %}
                {%- set index = generatorService.uniqueIdentifier() %}
                {%- set element_size_id = generatorService.uniqueIdentifier() %}
    // TODO: Handle Struct Arrays and Primitive arrays differently
    size_t {{ element_size_id }} = sizeof_{{ caseConversionService.convertToSnake(con.name) }}({{ generatorService.instance(key, 'instance') }});
    {{ generatorService.instance(key, 'instance') }} = ({{ generatorService.cType(subcon) }} *) malloc({{ generatorService.instance(generatorService.referencedSize(tree, key), 'instance') }} * sizeof({{ generatorService.cType(subcon) }}));
    for(size_t {{ index }} = 0; {{ index }} < {{ generatorService.instance(generatorService.referencedSize(tree, key), 'instance') }}; ++{{ index }})
        parse_{{ generatorService.cType(subcon) }}({{ generatorService.instance(key, 'instance') }}, source + offset + {{ index }} * {{ element_size_id }});
    }
    offset += {{ element_size_id }} * {{ generatorService.instance(generatorService.referencedSize(tree, key), 'instance') }};
            {%- elif generatorService.isStruct(key, tree) %}
    parse_{{ generatorService.cType(subcon) }}({{ generatorService.instance(key, 'instance') }}, source + offset);
    offset += sizeof_{{ generatorService.cType(subcon) }}({{ generatorService.instance(key, 'instance') }});
            {%- else %}
    // Unhandled @ {{ key }} / {{ subcon }}
            {%- endif %}
        {%- endif %}
    {%- endfor %}
}
{%- endmacro %}

#ifndef {{ caseConversionService.convertToMacro(info.baseName) }}_C
#define {{ caseConversionService.convertToMacro(info.baseName) }}_C

#ifndef {{ caseConversionService.convertToMacro(info.baseName) }}_HEADER_ONLY
#include "{{ info.baseName }}.h"
#endif /* {{ caseConversionService.convertToMacro(info.baseName) }}_HEADER_ONLY */

{%- if info.needsMalloc %}
#include <stdlib.h>
{%- endif %}

#ifdef {{ caseConversionService.convertToMacro(info.baseName) }}_SIZEOF
// Sizeof-related implementations.
{%- for _struct in info.structStack %}
    {{ generate_sizeof( generatorService.subtree(caseConversionService.convertToSnake(_struct.name), generatorService.tree(_struct)), _struct) }}
{%- endfor %}
#endif /* {{ caseConversionService.convertToMacro(info.baseName) }}_SIZEOF */

#ifdef {{ caseConversionService.convertToMacro(info.baseName) }}_PARSER
// Parser-related implementations.
{%- for _struct in info.structStack %}
    {{ generate_parser( generatorService.subtree(caseConversionService.convertToSnake(_struct.name), generatorService.tree(_struct)), _struct) }}
{%- endfor %}
#endif /* {{ caseConversionService.convertToMacro(info.baseName) }}_PARSER */

#ifdef {{ caseConversionService.convertToMacro(info.baseName) }}_SERIALIZER

#endif /* {{ caseConversionService.convertToMacro(info.baseName) }}_SERIALIZER */

#endif /* {{ caseConversionService.convertToMacro(info.baseName) }}_C */
