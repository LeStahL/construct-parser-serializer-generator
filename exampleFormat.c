/* 
 * Generated by construct-parser-serializer-generator (c) 2023 Alexander Kraus <nr4@z10.info>.
 * Generation timestamp: 2025-05-02 13:23:45.385241
 * Note: If you plan to edit this file, please reconsider your plan.
 */

#include <stdlib.h>
#include <string.h>

#ifndef EXAMPLE_FORMAT_C
#define EXAMPLE_FORMAT_C

#ifndef EXAMPLE_FORMAT_HEADER_ONLY
#include "exampleFormat.h"
#endif /* EXAMPLE_FORMAT_HEADER_ONLY */
#include <stdlib.h>
#ifdef DEBUG
#include <stdio.h>
#endif // DEBUG

#ifdef EXAMPLE_FORMAT_SIZEOF
// Sizeof-related implementations.
    
size_t sizeof_array_content_t(array_content_t *instance) {
    size_t result = 0;
    // array_content.struct_entry with type uint8_t:
    result += 1;
    // array_content.this_a_string with type char *:
    result += instance->struct_entry;
    // array_content.nested_array_size with type uint8_t:
    result += 1;
    // array_content.nested_array with type uint8_t *:
    // Handling array.
    result += instance->nested_array_size;
    // array_content.texture_internal_format with type texture_internal_format_t:
    result += 1;
    return result;
}
    
size_t sizeof_sub_struct_t(sub_struct_t *instance) {
    size_t result = 0;
    // sub_struct.other_data with type uint32_t:
    result += 4;
    // sub_struct.more_data with type int32_t:
    result += 4;
    return result;
}
    
size_t sizeof_example_format_t(example_format_t *instance) {
    size_t result = 0;
    // example_format.data with type uint8_t:
    result += 1;
    // example_format.sub_struct with type sub_struct_t:
    result += sizeof_sub_struct_t(&instance->sub_struct);
    // example_format.size with type uint32_t:
    result += 4;
    // example_format.string with type char *:
    result += instance->size;
    // example_format.array_size with type uint32_t:
    result += 4;
    // example_format.we_need_array_support with type array_content_t *:
    // Handling array.
    for(size_t ra0 = 0; ra0 < instance->array_size; ++ra0) {
        result += sizeof_array_content_t(instance->we_need_array_support + ra0);
    }
    // example_format.floats_are_cool with type float:
    result += 4;
    return result;
}
#endif /* EXAMPLE_FORMAT_SIZEOF */

#ifdef EXAMPLE_FORMAT_PARSER
// Parser-related implementations.
    
void parse_array_content_t(array_content_t *instance, uint8_t *source) {
    size_t offset = 0;
    // array_content.struct_entry with type uint8_t:
#ifdef DEBUG
    printf("Parsing %s (type %s) at offset %d.\n", "array_content.struct_entry", "uint8_t", (int32_t)offset);
#endif // DEBUG
    instance->struct_entry = *(uint8_t *)(source + offset);
    offset += 1;
#ifdef DEBUG
    printf("Parsed computable: None\n", (uint8_t)instance->struct_entry);
#endif // DEBUG
    // array_content.this_a_string with type char *:
#ifdef DEBUG
    printf("Parsing %s (type %s) at offset %d.\n", "array_content.this_a_string", "char *", (int32_t)offset);
#endif // DEBUG
    instance->this_a_string = (char *) malloc(instance->struct_entry + 1);
    memcpy(instance->this_a_string, source + offset, instance->struct_entry);
    instance->this_a_string[instance->struct_entry] = 0;
    offset += instance->struct_entry;
#ifdef DEBUG
    printf("Parsed string: %s\n", instance->this_a_string);
#endif // DEBUG
    // array_content.nested_array_size with type uint8_t:
#ifdef DEBUG
    printf("Parsing %s (type %s) at offset %d.\n", "array_content.nested_array_size", "uint8_t", (int32_t)offset);
#endif // DEBUG
    instance->nested_array_size = *(uint8_t *)(source + offset);
    offset += 1;
#ifdef DEBUG
    printf("Parsed computable: None\n", (uint8_t)instance->nested_array_size);
#endif // DEBUG
    // array_content.nested_array with type uint8_t *:
#ifdef DEBUG
    printf("Parsing %s (type %s) at offset %d.\n", "array_content.nested_array", "uint8_t *", (int32_t)offset);
#endif // DEBUG
#ifdef DEBUG
    printf("Parsing array of size %d.\n", instance->nested_array_size);
#endif // DEBUG
    // array_content.texture_internal_format with type texture_internal_format_t:
#ifdef DEBUG
    printf("Parsing %s (type %s) at offset %d.\n", "array_content.texture_internal_format", "texture_internal_format_t", (int32_t)offset);
#endif // DEBUG
    instance->texture_internal_format = (texture_internal_format_t)*(uint8_t *)(source + offset);
    offset += 1;
#ifdef DEBUG
    printf("Parsed enum of type %s: %d\n", "texture_internal_format_t", instance->texture_internal_format);
#endif // DEBUG
}
    
void parse_sub_struct_t(sub_struct_t *instance, uint8_t *source) {
    size_t offset = 0;
    // sub_struct.other_data with type uint32_t:
#ifdef DEBUG
    printf("Parsing %s (type %s) at offset %d.\n", "sub_struct.other_data", "uint32_t", (int32_t)offset);
#endif // DEBUG
    instance->other_data = *(uint32_t *)(source + offset);
    offset += 4;
#ifdef DEBUG
    printf("Parsed computable: %lu\n", (uint32_t)instance->other_data);
#endif // DEBUG
    // sub_struct.more_data with type int32_t:
#ifdef DEBUG
    printf("Parsing %s (type %s) at offset %d.\n", "sub_struct.more_data", "int32_t", (int32_t)offset);
#endif // DEBUG
    instance->more_data = *(int32_t *)(source + offset);
    offset += 4;
#ifdef DEBUG
    printf("Parsed computable: %ld\n", (int32_t)instance->more_data);
#endif // DEBUG
}
    
void parse_example_format_t(example_format_t *instance, uint8_t *source) {
    size_t offset = 0;
    // example_format.data with type uint8_t:
#ifdef DEBUG
    printf("Parsing %s (type %s) at offset %d.\n", "example_format.data", "uint8_t", (int32_t)offset);
#endif // DEBUG
    instance->data = *(uint8_t *)(source + offset);
    offset += 1;
#ifdef DEBUG
    printf("Parsed computable: None\n", (uint8_t)instance->data);
#endif // DEBUG
    // example_format.sub_struct with type sub_struct_t:
#ifdef DEBUG
    printf("Parsing %s (type %s) at offset %d.\n", "example_format.sub_struct", "sub_struct_t", (int32_t)offset);
#endif // DEBUG
    parse_sub_struct_t(&instance->sub_struct, source + offset);
    offset += sizeof_sub_struct_t(&instance->sub_struct);
    // example_format.size with type uint32_t:
#ifdef DEBUG
    printf("Parsing %s (type %s) at offset %d.\n", "example_format.size", "uint32_t", (int32_t)offset);
#endif // DEBUG
    instance->size = *(uint32_t *)(source + offset);
    offset += 4;
#ifdef DEBUG
    printf("Parsed computable: %lu\n", (uint32_t)instance->size);
#endif // DEBUG
    // example_format.string with type char *:
#ifdef DEBUG
    printf("Parsing %s (type %s) at offset %d.\n", "example_format.string", "char *", (int32_t)offset);
#endif // DEBUG
    instance->string = (char *) malloc(instance->size + 1);
    memcpy(instance->string, source + offset, instance->size);
    instance->string[instance->size] = 0;
    offset += instance->size;
#ifdef DEBUG
    printf("Parsed string: %s\n", instance->string);
#endif // DEBUG
    // example_format.array_size with type uint32_t:
#ifdef DEBUG
    printf("Parsing %s (type %s) at offset %d.\n", "example_format.array_size", "uint32_t", (int32_t)offset);
#endif // DEBUG
    instance->array_size = *(uint32_t *)(source + offset);
    offset += 4;
#ifdef DEBUG
    printf("Parsed computable: %lu\n", (uint32_t)instance->array_size);
#endif // DEBUG
    // example_format.we_need_array_support with type array_content_t *:
#ifdef DEBUG
    printf("Parsing %s (type %s) at offset %d.\n", "example_format.we_need_array_support", "array_content_t *", (int32_t)offset);
#endif // DEBUG
#ifdef DEBUG
    printf("Parsing array of size %d.\n", instance->array_size);
#endif // DEBUG
    // example_format.floats_are_cool with type float:
#ifdef DEBUG
    printf("Parsing %s (type %s) at offset %d.\n", "example_format.floats_are_cool", "float", (int32_t)offset);
#endif // DEBUG
    instance->floats_are_cool = *(float *)(source + offset);
    offset += 4;
#ifdef DEBUG
    printf("Parsed computable: %e\n", (float)instance->floats_are_cool);
#endif // DEBUG
}
#endif /* EXAMPLE_FORMAT_PARSER */

#ifdef EXAMPLE_FORMAT_SERIALIZER
// Serializer-related implementations.
    
void serialize_array_content_t(array_content_t *instance, uint8_t *target) {
    size_t offset = 0;
    // array_content.struct_entry with type uint8_t:
    *(uint8_t *)(target + offset) = instance->struct_entry;
    offset += 1;
    // array_content.this_a_string with type char *:
    memcpy(target + offset, instance->this_a_string, instance->struct_entry);
    offset += instance->struct_entry;
    // array_content.nested_array_size with type uint8_t:
    *(uint8_t *)(target + offset) = instance->nested_array_size;
    offset += 1;
    // array_content.nested_array with type uint8_t *:
    size_t ra4 = sizeof_nested_array_t(instance->nested_array);
    memcpy(target + offset, instance->nested_array, instance->nested_array_size);
                
    offset += ra4 * instance->nested_array_size;
    // array_content.texture_internal_format with type texture_internal_format_t:
    *(uint8_t *)(target + offset) = (uint8_t)instance->texture_internal_format;
    offset += 1;
}
    
void serialize_sub_struct_t(sub_struct_t *instance, uint8_t *target) {
    size_t offset = 0;
    // sub_struct.other_data with type uint32_t:
    *(uint32_t *)(target + offset) = instance->other_data;
    offset += 4;
    // sub_struct.more_data with type int32_t:
    *(int32_t *)(target + offset) = instance->more_data;
    offset += 4;
}
    
void serialize_example_format_t(example_format_t *instance, uint8_t *target) {
    size_t offset = 0;
    // example_format.data with type uint8_t:
    *(uint8_t *)(target + offset) = instance->data;
    offset += 1;
    // example_format.sub_struct with type sub_struct_t:
    serialize_sub_struct_t(&instance->sub_struct, target + offset);
    offset += sizeof_sub_struct_t(&instance->sub_struct);
    // example_format.size with type uint32_t:
    *(uint32_t *)(target + offset) = instance->size;
    offset += 4;
    // example_format.string with type char *:
    memcpy(target + offset, instance->string, instance->size);
    offset += instance->size;
    // example_format.array_size with type uint32_t:
    *(uint32_t *)(target + offset) = instance->array_size;
    offset += 4;
    // example_format.we_need_array_support with type array_content_t *:
    size_t ra6 = sizeof_array_content_t(instance->we_need_array_support);
    for(size_t ra5 = 0; ra5 < instance->array_size; ++ra5) {
        // TODO: This is a bug and should be fixed.
        serialize_array_content_t(instance->we_need_array_support + ra5, target + offset + ra5 * ra6);
    }
    offset += ra6 * instance->array_size;
    // example_format.floats_are_cool with type float:
    *(float *)(target + offset) = instance->floats_are_cool;
    offset += 4;
}
#endif /* EXAMPLE_FORMAT_SERIALIZER */

#ifdef EXAMPLE_FORMAT_DESTRUCTOR
// Destructor-related forward declarations
void free_array_content_t(array_content_t *instance) {
    free(instance->this_a_string);
}
    
void free_example_format_t(example_format_t *instance) {
    free(instance->string);
}
    
#endif /* EXAMPLE_FORMAT_DESTRUCTOR */

#endif /* EXAMPLE_FORMAT_C */